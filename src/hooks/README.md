# フックについてのメモ

ObjectTableの列名を外部から与える仕組みを作るにあたって
カスタムフックの挙動をそれに合わせて調整しています。

## usePriorityOrder
複数列の優先順位付きの並び替えを扱います

### 並び替え切り替え操作
昇順、降順、並び替えなしの 3 モードを切り替えられます。

複数の列に対して同時に設定された場合には、先に設定されたものから順に高い優先度（1, 2, 3...）が設定されます。

### 列名を追加した場合
オブジェクトに（まだ）存在していない列が追加された場合、
その列も並び替え切り替え操作が可能です。
ただ、追加された列の値はすべて空欄（undefined）でしょうから、
それに対する並び替え切り替え操作の結果は何も変化させません。

## useFilter
列の値を選択することでObjectTable向けの
データのフィルタを行います。
該当するデータのみが表示されるようになります。

フィルタ用のデータとして、以下の構造のデータを保持しています。
値ごとに boolean 型を対応させているのは、フィルタ編集用のコンポーネントでチェックボックスを用いて選択するためです。

TODO: 単純に値の配列にしてもよいのでは？←それではフィルタ候補がどれで、そのうちどれが有効になっているかの 2 段階の情報を保持することができないのでは？

```typescript
type FilterDict<T> = {
  [key: keyof T]: { [value: string]: boolean}
}

filterDict: FilterDict<T> = {
  '列名1': {
    '値1-1': false, // フィルタ対象か否か
    '値1-2': true,
    ...
  },
  '列名2': {
    '値2-1': false,
    '値2-2': false,
    ...
  },
  ...
}
```

フィルタを実際に適応する処理や、状態を確認するために `FilterDict<T>` は `FilterArra<T>` 型に変換されます

```typescript
type FilterArray<T> = { [key: keyof T]: string[] }

filterArray: FilterArray<T> = {
  '列名1': ['値1-2'],
}
```

意外と考えることが多く、コードが散らかっています。

フィルタ対象となっている値が編集されたとき...
1. 編集される前の値を持ったデータが1つしかなかった場合<br/>
  （編集した結果、編集前の値のデータが無くなる場合）
    - フィルタ用のデータを、編集後のデータに置き換えます
2. 編集される前の値を持ったデータが2つ以上ある場合<br/>
  （編集した結果、編集前の値と編集後の値の2種類以上となる場合）
    - フィルタ用のデータを、編集前と編集後の2つのデータに増やします
3. 編集した結果の値が、他のフィルタ用データの値と同じになった場合
    - フィルタ用のデータから、重複を削除するようにします

### 列名を追加した場合
オブジェクトに（まだ）存在していない列が追加された場合、
その列に対するフィルタ用データもまた作成されます。
ただ、追加された列の値はすべて空欄（undefined）でしょうから、
その列に対するフィルタ候補は 0 件、何も表示されません。

